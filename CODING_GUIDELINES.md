# CCLEMON 程式碼開發守則

本文件說明在 CCLEMON 專案中撰寫或修改程式碼時，應遵守的原則與慣例，目標是：**穩定、可維護、可測試、效能良好**。

---

## 1. 通用原則

1. **正確性優先，其次是可讀性，再來才是效能優化。**
2. **遵守專案既有技術棧與版本**：
   - Java 版本：21
   - Spring Boot：3.5.x
   - Spring Cloud：2025.0.x
   - 其他相依請以 `TECH_ARCHITECTURE.md` 與現有 `build.gradle` 為準。
3. **遵守既有架構與模組邊界**：新增功能時，先確認要落在哪一個模組，避免跨模組責任混亂。
4. **禁止未經評估的「炫技」寫法**：若降低可讀性，請不要使用。

---

## 2. 程式碼風格與可讀性

1. **保持簡潔、單一職責**：
   - 一個方法只做一件事，行數以能清楚表達為主，過長則應拆分。
2. **命名清楚有語意**：
   - 類別、方法、變數需用有意義的英文名稱，避免縮寫除非是業界通用（如 `id`, `url`, `dto`）。
3. **每個公開方法都應有註解**：
   - 使用 Javadoc（`/** ... */`）簡要描述：用途、輸入參數、回傳值與例外狀況。
4. **避免魔法數字／字串**：
   - 重要常數使用 `private static final` 常數定義，並加註解。
5. **控制巢狀層級**：
   - 盡量避免多層 `if/else` / `try/catch` 巢狀，必要時抽出成獨立方法。

---

## 3. 測試與品質保證

1. **任何新功能或修正，都必須同時撰寫或更新測試。**
2. **覆蓋正常流程與邊界情境（edge cases）**：
   - 包含：null／空值、極大／極小值、不合法輸入、例外路徑、併發情境（若相關）。
3. **單元測試（Unit Test）優先**：
   - Service / Utility 類別應有對應的單元測試。
4. **整合測試（Integration Test）用於關鍵流程**：
   - 涉及資料庫、Kafka、Redis、HTTP 的關鍵流程應有至少一個整合測試案例。
5. **測試可重複執行且彼此獨立**：
   - 不應依賴執行順序，不應依賴外部「髒資料」。

---

## 4. 錯誤處理與穩定性

1. **不得吞掉例外**：
   - 禁用空的 `catch` 區塊，所有例外都應被記錄（log）或合理轉譯（wrap）。
2. **對外 API 回應需穩定且可預期**：
   - 不將內部實作細節（stack trace、內部錯誤訊息）直接暴露給客戶端。
3. **合理使用 `Retry` 與超時（timeout）**：
   - 外部呼叫（如 Config Server、Authorization Server）失敗時，應有重試與 timeout 機制，避免無限等待。
4. **交易與一致性**：
   - 與資料庫互動時，清楚界定 transaction 邊界，避免半寫入狀態。
5. **避免靜態全域可變狀態**：
   - 若必須使用，需謹慎評估 thread-safety 與生命週期。

---

## 5. 效能與資源使用

1. **避免不必要的重複查詢與 N+1 問題**：
   - 使用適當的 `fetch` 策略與批次查詢，必要時加入 `JOIN FETCH` 或專用查詢方法。
2. **對集合與串流操作保持謹慎**：
   - 避免在大型集合上進行不必要的複雜運算；可先過濾再轉換，減少中間物件建立。
3. **謹慎使用日誌（logging）**：
   - 避免在熱路徑中記錄過多 `INFO` / `DEBUG`。
   - 對大量迴圈或批次處理，請只在關鍵節點記錄必要資訊。
4. **合理運用快取（Cache）**：
   - 使用 Redis 或應用層快取時，明確定義快取 key 與失效策略，避免過期資料影響正確性。
5. **非必要不要提早優化**：
   - 若無實際效能問題，先以清晰與正確為主；遇到瓶頸再依據監控資料調整。

---

## 6. 安全性與資料保護

1. **遵守既有安全架構**：
   - 所有受保護 API 必須走 OAuth2 Resource Server 機制驗證 JWT，不得繞過。
2. **禁止在程式碼中硬編機密資訊**：
   - 不得將密碼、憑證、Client Secret 寫死在程式碼，需透過設定與秘密管理機制。
3. **日誌不得記錄敏感資訊**：
   - 如密碼、完整 Token、個資（PII）等，必要時需遮罩（masking）。

---

## 7. 日誌與監控

1. **重要流程應有足夠的 log**：
   - 包含：關鍵輸入參數、外部呼叫結果、錯誤原因。
2. **使用既有的 logging 規範**：
   - 優先沿用 `cclemon-logging` 模組提供的格式與設定。
3. **錯誤與例外請至少記錄為 `WARN` 或 `ERROR`**。

---

## 8. API 設計與相容性

1. **對外 API 需考慮版本相容**：
   - 若有破壞性變更，應考慮版本化（如 `/api/v1/...` → `/api/v2/...`）。
2. **Request / Response 結構需保持穩定與清晰**：
   - 不隨意更動欄位名稱；需要變更時，先評估使用端影響。
3. **錯誤回應格式統一**：
   - 保持統一的錯誤格式（如錯誤碼＋訊息），方便前端與其他服務處理。

---

## 9. 程式碼變更流程

1. **每次變更都應包含：程式碼 + 測試 + 必要文件更新。**
2. **若手動修改程式碼導致架構、業務行為或公開 API 有變動**：
   - 必須同步更新（或至少檢查是否需更新）`TECH_ARCHITECTURE.md`、`BUSINESS_ARCHITECTURE.md`、`CODING_GUIDELINES.md` 等相關文件，避免文件記憶與實際程式碼不一致。
3. **PR / Code Review 原則（若有）**：
   - 說明變更目的、影響範圍與測試結果。
   - 變更範圍盡量聚焦，避免一次大規模混合修改。
4. **任何破壞性變更需在說明中明確標註。**

---

## 10. 針對 AI 助手的額外規範

1. 若由 AI 產生程式碼：
   - 必須符合本文件所有條款，且使用專案既有技術棧與版本。
   - 必須一併產生或建議相對應的測試案例（包含 edge cases）。
   - 必須保持程式碼可讀、易於理解，並加入必要註解／Javadoc。
2. 若 AI 需要在不同實作方案中做選擇：
   - 優先選擇：簡潔、易維護、與現有風格一致的方案。
3. 若 AI 的建議與既有程式風格或檔案（例如 `TECH_ARCHITECTURE.md`、`BUSINESS_ARCHITECTURE.md`）衝突：
   - 應以既有文件為準，必要時調整建議方案。